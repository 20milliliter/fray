#TODO: Make sure there is some way to support the following scenario...
	# Player holds down while pressing other buttons.
	# Player attempts to input 236P without first releasing and reinputing the 2
	# 236P input is recognized and accepted.

extends "sequence_analyzer.gd"
## Tree based implementation of SequenceAnalyzer.
##
## @desc:
## 		This analyzer stores sequences in a tree data structure and then attempts to
##		match to match them to the incoming input with each read call.

const Sequence = preload("sequence.gd")

var _root := InputNode.new()
var _current_node: InputNode = _root
var _rescan_start_index: int = 1
var _is_initialized: bool

## Type: FrayInputEvent[]
var _input_event_queue: Array


func _read(input_event: FrayInputEvent) -> void:
	if not _is_initialized:
		push_warning("Failed to read input event. Sequence analyzer is not initialized")
		return
	
	var next_node := _current_node.get_next(input_event.input)

	if next_node == null or not input_event.is_just_pressed(true):
		return

	_input_event_queue.append(input_event)

	if next_node != null:
		_current_node = next_node
	else:
		_rescan()

	for name in _current_node.data:
		var sequences: Array = _current_node.data[name]
		
		for sequence in sequences:
			if is_match(_input_event_queue, sequence.input_requirements):
				_rescan_start_index = _input_event_queue.size()
				emit_signal("match_found", name, _get_inputs_as_int_array())
				break

	if _current_node != _root and _current_node.get_child_count() == 0:
		revert()


func initialize(sequence_collection: SequenceCollection) -> void:
	for name in sequence_collection.get_sequence_names():
		var sequences := sequence_collection.get_sequences(name)
		
		for sequence in sequences:
			var next_node := _root

			for req in sequence.input_requirements:
				var prev_node = next_node
				next_node = next_node.get_next(req.input)

				if next_node == null:
					next_node = InputNode.new()
					next_node.input = req.input
					prev_node.add_node(next_node)
			
			if not next_node.data.has(name):
				next_node.data[name] = []

			next_node.data[name].append(sequence)
	_is_initialized = true

## Reverts the tree's scanner back to the root
func revert() -> void:
	_current_node = _root
	_rescan_start_index = 1
	_input_event_queue.clear()

## Destroys the tree generated by add_sequence
func destroy_tree() -> void:
	_root.clear()
	_current_node = _root


func _rescan() -> void:
	var has_sub_sequence_match: bool = false

	if _input_event_queue.size() >= 2:
		var input_count: int = _input_event_queue.size() 
		
		for scan_index in range(_rescan_start_index, input_count):
			var next_node = _root

			for i in range(scan_index, input_count):
				next_node = next_node.get_next(_input_event_queue[i].id)

				if next_node == null:
					break

			if next_node != null:
				_current_node = next_node
				_input_event_queue = _input_event_queue.slice(scan_index, input_count)
				has_sub_sequence_match = true
				_rescan_start_index = 1
				return

	revert()


func _get_inputs_as_path() -> String:
	var path: PoolStringArray

	for input_event in _input_event_queue:
		path.append(str(input_event.input))

	return path.join(">")

func _get_inputs_as_int_array() -> PoolIntArray:
	var path: PoolIntArray

	for input_event in _input_event_queue:
		path.append(input_event.input)

	return path

#signal methods

class InputNode:
	extends Reference
	
	var input: String
	
	## Dictionary<String, Sequence[]>
	var data: Dictionary
	#TODO: Things using data expect the objects in the array to have a
	#sequence_name property. Need to come up with a way of resolving that

	var _next_nodes: Array # InputNode[]

	func add_node(node: InputNode) -> void:
		_next_nodes.append(node)


	func get_next(input: String) -> InputNode:
		for node in _next_nodes:
			if node.input == input:
				return node
		return null


	func has_next(input: String) -> bool:
		return get_next(input) != null
	

	func get_child_count() -> int:
		return _next_nodes.size()


	func clear() -> void:
		_next_nodes.clear()
