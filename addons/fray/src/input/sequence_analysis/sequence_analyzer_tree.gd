#TODO: Make sure there is some way to support the following scenario...
	# Player holds down while pressing other buttons.
	# Player attempts to input 236P without first releasing and reinputing the 2
	# 236P input is recognized and accepted.

extends "sequence_analyzer.gd"
## Tree based implementation of SequenceAnalyzer.
##
## @desc:
## 		This analyzer stores sequences in a tree data structure and then attempts to
##		match to match them to the incoming input with each read call.

const Sequence = preload("sequence.gd")

var _root := InputNode.new()
var _current_node: InputNode = _root
var _rescan_start_index: int = 1

## Type: FrayInputEvent[]
var _input_queue: Array


func _read(input_event: FrayInputEvent) -> void:
	var next_node := _current_node.get_next(input_event.id)

	if next_node == null and not input_event.is_just_pressed_filtered():
		return

	_input_queue.append(input_event)

	if next_node != null:
		_current_node = next_node
	else:
		_rescan()

	for name in _current_node.data:
		var sequence: Sequence = _current_node.data[name]
		if is_match(_input_queue, sequence.input_requirements):
			_rescan_start_index = _input_queue.size()
			emit_signal("match_found", name, _get_inputs_as_int_array())

	if _current_node != _root and _current_node.get_child_count() == 0:
		revert()


func initialize(sequence_collection: SequenceCollection) -> void:
	for name in sequence_collection.get_sequence_names():
		var sequences := sequence_collection.get_sequences(name)
		
		for sequence in sequences:
			var next_node := _root

			for req in sequence.input_requirements:
				var prev_node = next_node
				next_node = next_node.get_next(req.input_id)

				if next_node == null:
					next_node = InputNode.new()
					next_node.id = req.input_id
					prev_node.add_node(next_node)
			
			if not next_node.data.has(name):
				next_node.data[name] = []

			next_node.data[name].append(sequence)


## Reverts the tree's scanner back to the root
func revert() -> void:
	_current_node = _root
	_rescan_start_index = 1
	_input_queue.clear()

## Destroys the tree generated by add_sequence
func destroy_tree() -> void:
	_root.clear()
	_current_node = _root


func _rescan() -> void:
	var has_sub_sequence_match: bool = false

	if _input_queue.size() >= 2:
		var input_count: int = _input_queue.size() 
		
		for scan_index in range(_rescan_start_index, input_count):
			var next_node = _root

			for i in range(scan_index, input_count):
				next_node = next_node.get_next(_input_queue[i].id)

				if next_node == null:
					break

			if next_node != null:
				_current_node = next_node
				_input_queue = _input_queue.slice(scan_index, input_count)
				has_sub_sequence_match = true
				_rescan_start_index = 1
				return

	revert()


func _get_inputs_as_path() -> String:
	var path: PoolStringArray

	for input in _input_queue:
		path.append(str(input.id))

	return path.join(">")

func _get_inputs_as_int_array() -> PoolIntArray:
	var path: PoolIntArray

	for input in _input_queue:
		path.append(input.id)

	return path

#signal methods

class InputNode:
	extends Reference
	
	var id: int
	
	## Dictionary<String, Sequence[]>
	var data: Dictionary
	#TODO: Things using data expect the objects in the array to have a
	#sequence_name property. Need to come up with a way of resolving that

	var _next_nodes: Array # InputNode[]

	func add_node(node: InputNode) -> void:
		_next_nodes.append(node)


	func get_next(id: int) -> InputNode:
		for node in _next_nodes:
			if node.id == id:
				return node
		return null


	func has_next(id: int) -> bool:
		return get_next(id) != null
	

	func get_child_count() -> int:
		return _next_nodes.size()


	func clear() -> void:
		_next_nodes.clear()
